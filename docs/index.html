

<!DOCTYPE html>
<meta charset="utf-8">
<head>
<link rel="stylesheet" type="text/css" href="map.css">

</head>


<script src="https://d3js.org/d3.v4.min.js"></script> 
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script> 
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> 
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script src="https://d3js.org/d3-axis.v1.min.js"></script>
<script src="https://d3js.org/d3-drag.v1.min.js"></script>
<script src="https://cdn.rawgit.com/vast-engineering/jquery-popup-overlay/1.7.13/jquery.popupoverlay.js"></script>
<script src="js/keybinding.js"></script>
<body>

</body>

<script type="text/javascript">


var grid = d3.select("body")
  .append("div")
  .attr("id", "grid")
  .attr("class", "grid");

var div = d3.select("body").append("div") 
    .attr("class", "tooltip")       
    .style("opacity", 0);
    
  grid
  .append("div")
  .attr("class", "row_divs")
  .append("h1")
  .attr("id", "title_text")
  .text("The unemployment rate has recovered nicely since the financial crisis.");


// set the dimensions and margins of the graph
var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

// parse the date / time
var parseTime = d3.timeParse("%Y-%m-%d");

// set the ranges
var x = d3.scaleTime().range([0, width]);
var y = d3.scaleLinear().range([height, 0]);

// define the line
var valueline = d3.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.unrate); });

var lfpr_line = d3.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.lfpr); });


var svg = grid.append("div").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");


      // Add the X Axis
  var xAxis = svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .attr('id','xaxis')
      .call(d3.axisBottom(x).ticks(5).tickFormat(d3.timeFormat("%Y")));


  

// Get the data
d3.csv("data.csv", function(error, data) {
  if (error) throw error;

  // format the data
  data.forEach(function(d) {
      d.date = parseTime(d.DATE);
      d.unrate = +d.UNRATE;
      d.lfpr = +d.notinLF;//+d.LFPR;
  });

  // Scale the range of the data
  x.domain(d3.extent(data, function(d) { return d.date; }));
  // y.domain([0, d3.max(data, function(d) { return d.unrate; })]);
y.domain([0,10]);


// Add the Y Axis
  var yAxis = svg.append("g")
    .attr('id', 'yaxis')
      .call(d3.axisLeft(y));
  

  //     // Add the X Axis
  // var xAxis = svg.append("g")
  //     .attr("transform", "translate(0," + height + ")")
  //     .attr('id','xaxis')
  //     .call(d3.axisBottom(x).ticks(5).tickFormat(d3.timeFormat("%Y")));

  // // Add the Y Axis
  // var yAxis = svg.append("g")
  //   .attr('id', 'yaxis')
  //     .call(d3.axisLeft(y));
  
  // UE
  path =  svg.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("id", "emp_line")
      .attr("stroke", "red")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("stroke-width", 2.5)
      .attr("d", valueline);

      console.log(path)

  totalLength = path.node().getTotalLength();

  path
      .attr("stroke-dasharray", totalLength + " " + totalLength)
      .attr("stroke-dashoffset", totalLength)
      .transition()
      .duration(2500)
      .attr("stroke-dashoffset", 0);




//onclick 


d3.select('body').call(d3.keybinding()
    .on('â†’', function(d){

       // add LFPR
  lfpr_path =  svg.append("path")
      .datum(data)
      .attr("fill", "none")
      // .attr("id", "emp_line")
      .attr("stroke", "blue")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("stroke-width", 2.5)
      .attr("d", lfpr_line);

      console.log(path)

  totalLengthLFPR = path.node().getTotalLength();

  lfpr_path
      .attr("stroke-dasharray", totalLengthLFPR + " " + totalLengthLFPR)
      .attr("stroke-dashoffset", totalLengthLFPR)
      .transition()
      // .delay(1000)
      .duration(2500)
      .attr("stroke-dashoffset", 0);




      y.domain([0,50]);

      var bod = d3.select("body").transition();

    // Make the changes
        bod.select("#emp_line")   // change the line
            .duration(750)
            .attr("d", valueline(data));
        // svg.select(".x.axis") // change the x axis
            // .duration(750)
            // .call(xAxis);
        bod.select("#yaxis") // change the y axis
            .duration(750)
            .call(yAxis);

      // d3.select('#emp_line').remove();

      //  path =  svg.append("path")
      // .datum(data)
      // .attr("fill", "none")
      // .attr("id", "emp_line2")
      // .attr("stroke", "red")
      // .attr("stroke-linejoin", "round")
      // .attr("stroke-linecap", "round")
      // .attr("stroke-width", 2.5)
      // .attr("d", valueline);

        // Add the Y Axis
        d3.select("#yaxis").remove();
  svg.append("g")
      .call(d3.axisLeft(y));


      console.log('pressed?')
    })
    );


  // //
  // // LFPR
  // lfpr_path =  svg.append("path")
  //     .datum(data)
  //     .attr("fill", "none")
  //     // .attr("id", "emp_line")
  //     .attr("stroke", "blue")
  //     .attr("stroke-linejoin", "round")
  //     .attr("stroke-linecap", "round")
  //     .attr("stroke-width", 2.5)
  //     .attr("d", lfpr_line);

  //     console.log(path)

  // totalLengthLFPR = path.node().getTotalLength();

  // lfpr_path
  //     .attr("stroke-dasharray", totalLengthLFPR + " " + totalLengthLFPR)
  //     .attr("stroke-dashoffset", totalLengthLFPR)
  //     .transition()
  //     .delay(1000)
  //     .duration(2500)
  //     .attr("stroke-dashoffset", 0);







});

  





// var w = 700;
//     var h = 300;

// var svg = grid.append("div")
//       .attr("class", "row_divs")
//       .append("svg")
//       .attr("width", w)
//       .attr("height", h)
//       .attr("id", "visualization")
//       .attr("xmlns", "http://www.w3.org/2000/svg");

//     var data = d3.range(11).map(function(){return Math.random()*10})
//     var x = d3.scaleLinear().domain([0, 10]).range([0, 700]);
//     var y = d3.scaleLinear().domain([0, 10]).range([10, 290]);
//     var line = d3.svg.line()
//       .interpolate("cardinal")
//       .x(function(d,i) {return x(i);})
//       .y(function(d) {return y(d);})

//     var path = svg.append("path")
//       .attr("d", line(data))
//       .attr("stroke", "steelblue")
//       .attr("stroke-width", "2")
//       .attr("fill", "none");

//     var totalLength = path.node().getTotalLength();

//     path
//       .attr("stroke-dasharray", totalLength + " " + totalLength)
//       .attr("stroke-dashoffset", totalLength)
//       .transition()
//         .duration(2000)
//         .ease("linear")
//         .attr("stroke-dashoffset", 0);

//     svg.on("click", function(){
//       path      
//         .transition()
//         .duration(2000)
//         .ease("linear")
//         .attr("stroke-dashoffset", totalLength);
//     })

// var keyPressed = {};

// function pressed(){

//  d3.select('body')  
//   .on('keydown', function() {
//     keyPressed[d3.event.keyIdentifier] = true;
//   })
//   .on('keyup', function() {
//     keyPressed[d3.event.keyIdentifier] = false;
//   });


// console.log('keyPressed', keyPressed['up'])

// if (keyPressed['Down']) {
//   console.log('down??');
// };

// }


// d3.timer(pressed);



</script>